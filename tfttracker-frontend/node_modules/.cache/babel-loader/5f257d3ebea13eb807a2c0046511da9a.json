{"ast":null,"code":"let fs = require('fs');\n\nlet path = require('path');\n\nlet cnst = require('constants');\n\nlet os = require('os');\n\nlet rimraf = require('rimraf');\n\nlet mkdirp = require('mkdirp');\n\nlet osTmpdir = require('os').tmpdir();\n\nconst rimrafSync = rimraf.sync; //== helpers\n//\n\nlet dir = path.resolve(os.tmpdir());\nlet RDWR_EXCL = cnst.O_CREAT | cnst.O_TRUNC | cnst.O_RDWR | cnst.O_EXCL;\n\nlet promisify = function (callback) {\n  if (typeof callback === 'function') {\n    return [undefined, callback];\n  }\n\n  var promiseCallback;\n  var promise = new Promise(function (resolve, reject) {\n    promiseCallback = function () {\n      var args = Array.from(arguments);\n      var err = args.shift();\n      process.nextTick(function () {\n        if (err) {\n          reject(err);\n        } else if (args.length === 1) {\n          resolve(args[0]);\n        } else {\n          resolve(args);\n        }\n      });\n    };\n  });\n  return [promise, promiseCallback];\n};\n\nvar generateName = function (rawAffixes, defaultPrefix) {\n  var affixes = parseAffixes(rawAffixes, defaultPrefix);\n  var now = new Date();\n  var name = [affixes.prefix, now.getFullYear(), now.getMonth(), now.getDate(), '-', process.pid, '-', (Math.random() * 0x100000000 + 1).toString(36), affixes.suffix].join('');\n  return path.join(affixes.dir || dir, name);\n};\n\nvar parseAffixes = function (rawAffixes, defaultPrefix) {\n  var affixes = {\n    prefix: null,\n    suffix: null\n  };\n\n  if (rawAffixes) {\n    switch (typeof rawAffixes) {\n      case 'string':\n        affixes.prefix = rawAffixes;\n        break;\n\n      case 'object':\n        affixes = rawAffixes;\n        break;\n\n      default:\n        throw new Error(\"Unknown affix declaration: \" + affixes);\n    }\n  } else {\n    affixes.prefix = defaultPrefix;\n  }\n\n  return affixes;\n};\n/* -------------------------------------------------------------------------\n * Don't forget to call track() if you want file tracking and exit handlers!\n * -------------------------------------------------------------------------\n * When any temp file or directory is created, it is added to filesToDelete\n * or dirsToDelete. The first time any temp file is created, a listener is\n * added to remove all temp files and directories at exit.\n */\n\n\nvar tracking = false;\n\nvar track = function (value) {\n  tracking = value !== false;\n  return module.exports; // chainable\n};\n\nvar exitListenerAttached = false;\nvar filesToDelete = [];\nvar dirsToDelete = [];\n\nfunction deleteFileOnExit(filePath) {\n  if (!tracking) return false;\n  attachExitListener();\n  filesToDelete.push(filePath);\n}\n\nfunction deleteDirOnExit(dirPath) {\n  if (!tracking) return false;\n  attachExitListener();\n  dirsToDelete.push(dirPath);\n}\n\nfunction attachExitListener() {\n  if (!tracking) return false;\n\n  if (!exitListenerAttached) {\n    process.addListener('exit', function () {\n      try {\n        cleanupSync();\n      } catch (err) {\n        console.warn(\"Fail to clean temporary files on exit : \", err);\n        throw err;\n      }\n    });\n    exitListenerAttached = true;\n  }\n}\n\nfunction cleanupFilesSync() {\n  if (!tracking) {\n    return false;\n  }\n\n  var count = 0;\n  var toDelete;\n\n  while ((toDelete = filesToDelete.shift()) !== undefined) {\n    rimrafSync(toDelete, {\n      maxBusyTries: 6\n    });\n    count++;\n  }\n\n  return count;\n}\n\nfunction cleanupFiles(callback) {\n  var p = promisify(callback);\n  var promise = p[0];\n  callback = p[1];\n\n  if (!tracking) {\n    callback(new Error(\"not tracking\"));\n    return promise;\n  }\n\n  var count = 0;\n  var left = filesToDelete.length;\n\n  if (!left) {\n    callback(null, count);\n    return promise;\n  }\n\n  var toDelete;\n\n  var rimrafCallback = function (err) {\n    if (!left) {\n      // Prevent processing if aborted\n      return;\n    }\n\n    if (err) {\n      // This shouldn't happen; pass error to callback and abort\n      // processing\n      callback(err);\n      left = 0;\n      return;\n    } else {\n      count++;\n    }\n\n    left--;\n\n    if (!left) {\n      callback(null, count);\n    }\n  };\n\n  while ((toDelete = filesToDelete.shift()) !== undefined) {\n    rimraf(toDelete, {\n      maxBusyTries: 6\n    }, rimrafCallback);\n  }\n\n  return promise;\n}\n\nfunction cleanupDirsSync() {\n  if (!tracking) {\n    return false;\n  }\n\n  var count = 0;\n  var toDelete;\n\n  while ((toDelete = dirsToDelete.shift()) !== undefined) {\n    rimrafSync(toDelete, {\n      maxBusyTries: 6\n    });\n    count++;\n  }\n\n  return count;\n}\n\nfunction cleanupDirs(callback) {\n  var p = promisify(callback);\n  var promise = p[0];\n  callback = p[1];\n\n  if (!tracking) {\n    callback(new Error(\"not tracking\"));\n    return promise;\n  }\n\n  var count = 0;\n  var left = dirsToDelete.length;\n\n  if (!left) {\n    callback(null, count);\n    return promise;\n  }\n\n  var toDelete;\n\n  var rimrafCallback = function (err) {\n    if (!left) {\n      // Prevent processing if aborted\n      return;\n    }\n\n    if (err) {\n      // rimraf handles most \"normal\" errors; pass the error to the\n      // callback and abort processing\n      callback(err, count);\n      left = 0;\n      return;\n    } else {\n      count++;\n    }\n\n    left--;\n\n    if (!left) {\n      callback(null, count);\n    }\n  };\n\n  while ((toDelete = dirsToDelete.shift()) !== undefined) {\n    rimraf(toDelete, {\n      maxBusyTries: 6\n    }, rimrafCallback);\n  }\n\n  return promise;\n}\n\nfunction cleanupSync() {\n  if (!tracking) {\n    return false;\n  }\n\n  var fileCount = cleanupFilesSync();\n  var dirCount = cleanupDirsSync();\n  return {\n    files: fileCount,\n    dirs: dirCount\n  };\n}\n\nfunction cleanup(callback) {\n  var p = promisify(callback);\n  var promise = p[0];\n  callback = p[1];\n\n  if (!tracking) {\n    callback(new Error(\"not tracking\"));\n    return promise;\n  }\n\n  cleanupFiles(function (fileErr, fileCount) {\n    if (fileErr) {\n      callback(fileErr, {\n        files: fileCount\n      });\n    } else {\n      cleanupDirs(function (dirErr, dirCount) {\n        callback(dirErr, {\n          files: fileCount,\n          dirs: dirCount\n        });\n      });\n    }\n  });\n  return promise;\n} //== directories\n//\n\n\nconst mkdir = (affixes, callback) => {\n  const p = promisify(callback);\n  const promise = p[0];\n  callback = p[1];\n  let dirPath = generateName(affixes, 'd-');\n  mkdirp(dirPath, 0o700, err => {\n    if (!err) {\n      deleteDirOnExit(dirPath);\n    }\n\n    callback(err, dirPath);\n  });\n  return promise;\n};\n\nconst mkdirSync = affixes => {\n  let dirPath = generateName(affixes, 'd-');\n  mkdirp.sync(dirPath, 0o700);\n  deleteDirOnExit(dirPath);\n  return dirPath;\n}; //== files\n//\n\n\nconst open = (affixes, callback) => {\n  const p = promisify(callback);\n  const promise = p[0];\n  callback = p[1];\n  const path = generateName(affixes, 'f-');\n  fs.open(path, RDWR_EXCL, 0o600, (err, fd) => {\n    if (!err) {\n      deleteFileOnExit(path);\n    }\n\n    callback(err, {\n      path,\n      fd\n    });\n  });\n  return promise;\n};\n\nconst openSync = affixes => {\n  const path = generateName(affixes, 'f-');\n  let fd = fs.openSync(path, RDWR_EXCL, 0o600);\n  deleteFileOnExit(path);\n  return {\n    path,\n    fd\n  };\n};\n\nconst createWriteStream = affixes => {\n  const path = generateName(affixes, 's-');\n  let stream = fs.createWriteStream(path, {\n    flags: RDWR_EXCL,\n    mode: 0o600\n  });\n  deleteFileOnExit(path);\n  return stream;\n}; //== settings\n//\n\n\nexports.dir = dir;\nexports.track = track; //== functions\n//\n\nexports.mkdir = mkdir;\nexports.mkdirSync = mkdirSync;\nexports.open = open;\nexports.openSync = openSync;\nexports.path = generateName;\nexports.cleanup = cleanup;\nexports.cleanupSync = cleanupSync;\nexports.createWriteStream = createWriteStream;","map":{"version":3,"sources":["C:/Users/Brian/Desktop/TFTracker/TftTrackerCore/tfttracker-frontend/node_modules/temp/lib/temp.js"],"names":["fs","require","path","cnst","os","rimraf","mkdirp","osTmpdir","tmpdir","rimrafSync","sync","dir","resolve","RDWR_EXCL","O_CREAT","O_TRUNC","O_RDWR","O_EXCL","promisify","callback","undefined","promiseCallback","promise","Promise","reject","args","Array","from","arguments","err","shift","process","nextTick","length","generateName","rawAffixes","defaultPrefix","affixes","parseAffixes","now","Date","name","prefix","getFullYear","getMonth","getDate","pid","Math","random","toString","suffix","join","Error","tracking","track","value","module","exports","exitListenerAttached","filesToDelete","dirsToDelete","deleteFileOnExit","filePath","attachExitListener","push","deleteDirOnExit","dirPath","addListener","cleanupSync","console","warn","cleanupFilesSync","count","toDelete","maxBusyTries","cleanupFiles","p","left","rimrafCallback","cleanupDirsSync","cleanupDirs","fileCount","dirCount","files","dirs","cleanup","fileErr","dirErr","mkdir","mkdirSync","open","fd","openSync","createWriteStream","stream","flags","mode"],"mappings":"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","sourcesContent":["let fs   = require('fs');\nlet path = require('path');\nlet cnst = require('constants');\n\nlet os         = require('os');\nlet rimraf     = require('rimraf');\nlet mkdirp     = require('mkdirp');\nlet osTmpdir   = require('os').tmpdir();\n\nconst rimrafSync = rimraf.sync;\n\n//== helpers\n//\nlet dir = path.resolve(os.tmpdir());\n\nlet RDWR_EXCL = cnst.O_CREAT | cnst.O_TRUNC | cnst.O_RDWR | cnst.O_EXCL;\n\nlet promisify = function(callback) {\n  if (typeof callback === 'function') {\n    return [undefined, callback];\n  }\n\n  var promiseCallback;\n  var promise = new Promise(function(resolve, reject) {\n    promiseCallback = function() {\n      var args = Array.from(arguments);\n      var err = args.shift();\n\n      process.nextTick(function() {\n        if (err) {\n          reject(err);\n        } else if (args.length === 1) {\n          resolve(args[0]);\n        } else {\n          resolve(args);\n        }\n      });\n    };\n  });\n\n  return [promise, promiseCallback];\n};\n\nvar generateName = function(rawAffixes, defaultPrefix) {\n  var affixes = parseAffixes(rawAffixes, defaultPrefix);\n  var now = new Date();\n  var name = [affixes.prefix,\n              now.getFullYear(), now.getMonth(), now.getDate(),\n              '-',\n              process.pid,\n              '-',\n              (Math.random() * 0x100000000 + 1).toString(36),\n              affixes.suffix].join('');\n  return path.join(affixes.dir || dir, name);\n};\n\nvar parseAffixes = function(rawAffixes, defaultPrefix) {\n  var affixes = {prefix: null, suffix: null};\n  if(rawAffixes) {\n    switch (typeof(rawAffixes)) {\n    case 'string':\n      affixes.prefix = rawAffixes;\n      break;\n    case 'object':\n      affixes = rawAffixes;\n      break;\n    default:\n      throw new Error(\"Unknown affix declaration: \" + affixes);\n    }\n  } else {\n    affixes.prefix = defaultPrefix;\n  }\n  return affixes;\n};\n\n/* -------------------------------------------------------------------------\n * Don't forget to call track() if you want file tracking and exit handlers!\n * -------------------------------------------------------------------------\n * When any temp file or directory is created, it is added to filesToDelete\n * or dirsToDelete. The first time any temp file is created, a listener is\n * added to remove all temp files and directories at exit.\n */\nvar tracking = false;\nvar track = function(value) {\n  tracking = (value !== false);\n  return module.exports; // chainable\n};\nvar exitListenerAttached = false;\nvar filesToDelete = [];\nvar dirsToDelete = [];\n\nfunction deleteFileOnExit(filePath) {\n  if (!tracking) return false;\n  attachExitListener();\n  filesToDelete.push(filePath);\n}\n\nfunction deleteDirOnExit(dirPath) {\n  if (!tracking) return false;\n  attachExitListener();\n  dirsToDelete.push(dirPath);\n}\n\nfunction attachExitListener() {\n  if (!tracking) return false;\n  if (!exitListenerAttached) {\n    process.addListener('exit', function() {\n        try {\n            cleanupSync();\n        } catch(err) {\n            console.warn(\"Fail to clean temporary files on exit : \", err);\n            throw err;\n        }\n    });\n    exitListenerAttached = true;\n  }\n}\n\nfunction cleanupFilesSync() {\n  if (!tracking) {\n    return false;\n  }\n  var count = 0;\n  var toDelete;\n  while ((toDelete = filesToDelete.shift()) !== undefined) {\n    rimrafSync(toDelete, { maxBusyTries: 6 });\n    count++;\n  }\n  return count;\n}\n\nfunction cleanupFiles(callback) {\n  var p = promisify(callback);\n  var promise = p[0];\n  callback = p[1];\n\n  if (!tracking) {\n    callback(new Error(\"not tracking\"));\n    return promise;\n  }\n  var count = 0;\n  var left = filesToDelete.length;\n  if (!left) {\n    callback(null, count);\n    return promise;\n  }\n  var toDelete;\n  var rimrafCallback = function(err) {\n    if (!left) {\n      // Prevent processing if aborted\n      return;\n    }\n    if (err) {\n      // This shouldn't happen; pass error to callback and abort\n      // processing\n      callback(err);\n      left = 0;\n      return;\n    } else {\n      count++;\n    }\n    left--;\n    if (!left) {\n      callback(null, count);\n    }\n  };\n  while ((toDelete = filesToDelete.shift()) !== undefined) {\n    rimraf(toDelete, { maxBusyTries: 6 }, rimrafCallback);\n  }\n  return promise;\n}\n\nfunction cleanupDirsSync() {\n  if (!tracking) {\n    return false;\n  }\n  var count = 0;\n  var toDelete;\n  while ((toDelete = dirsToDelete.shift()) !== undefined) {\n    rimrafSync(toDelete, { maxBusyTries: 6 });\n    count++;\n  }\n  return count;\n}\n\nfunction cleanupDirs(callback) {\n  var p = promisify(callback);\n  var promise = p[0];\n  callback = p[1];\n\n  if (!tracking) {\n    callback(new Error(\"not tracking\"));\n    return promise;\n  }\n  var count = 0;\n  var left = dirsToDelete.length;\n  if (!left) {\n    callback(null, count);\n    return promise;\n  }\n  var toDelete;\n  var rimrafCallback = function (err) {\n    if (!left) {\n      // Prevent processing if aborted\n      return;\n    }\n    if (err) {\n      // rimraf handles most \"normal\" errors; pass the error to the\n      // callback and abort processing\n      callback(err, count);\n      left = 0;\n      return;\n    } else {\n      count++;\n    }\n    left--;\n    if (!left) {\n      callback(null, count);\n    }\n  };\n  while ((toDelete = dirsToDelete.shift()) !== undefined) {\n    rimraf(toDelete, { maxBusyTries: 6 }, rimrafCallback);\n  }\n  return promise;\n}\n\nfunction cleanupSync() {\n  if (!tracking) {\n    return false;\n  }\n  var fileCount = cleanupFilesSync();\n  var dirCount  = cleanupDirsSync();\n  return {files: fileCount, dirs: dirCount};\n}\n\nfunction cleanup(callback) {\n  var p = promisify(callback);\n  var promise = p[0];\n  callback = p[1];\n\n  if (!tracking) {\n    callback(new Error(\"not tracking\"));\n    return promise;\n  }\n  cleanupFiles(function(fileErr, fileCount) {\n    if (fileErr) {\n      callback(fileErr, {files: fileCount});\n    } else {\n      cleanupDirs(function(dirErr, dirCount) {\n        callback(dirErr, {files: fileCount, dirs: dirCount});\n      });\n    }\n  });\n  return promise;\n}\n\n//== directories\n//\nconst mkdir = (affixes, callback) => {\n  const p = promisify(callback);\n  const promise = p[0];\n  callback = p[1];\n\n  let dirPath = generateName(affixes, 'd-');\n  mkdirp(dirPath, 0o700, (err) => {\n    if (!err) {\n      deleteDirOnExit(dirPath);\n    }\n    callback(err, dirPath);\n  });\n  return promise;\n}\n\nconst mkdirSync = (affixes) => {\n  let dirPath = generateName(affixes, 'd-');\n  mkdirp.sync(dirPath, 0o700);\n  deleteDirOnExit(dirPath);\n  return dirPath;\n}\n\n//== files\n//\nconst open = (affixes, callback) => {\n  const p = promisify(callback);\n  const promise = p[0];\n  callback = p[1];\n\n  const path = generateName(affixes, 'f-');\n  fs.open(path, RDWR_EXCL, 0o600, (err, fd) => {\n    if (!err) {\n      deleteFileOnExit(path);\n    }\n    callback(err, { path, fd });\n  });\n  return promise;\n}\n\nconst openSync = (affixes) => {\n  const path = generateName(affixes, 'f-');\n  let fd = fs.openSync(path, RDWR_EXCL, 0o600);\n  deleteFileOnExit(path);\n  return { path, fd };\n}\n\nconst createWriteStream =  (affixes) => {\n  const path = generateName(affixes, 's-');\n  let stream = fs.createWriteStream(path, { flags: RDWR_EXCL, mode: 0o600 });\n  deleteFileOnExit(path);\n  return stream;\n}\n\n//== settings\n//\nexports.dir = dir;\nexports.track = track;\n\n//== functions\n//\nexports.mkdir = mkdir;\nexports.mkdirSync = mkdirSync;\nexports.open = open;\nexports.openSync = openSync;\nexports.path = generateName;\nexports.cleanup = cleanup;\nexports.cleanupSync = cleanupSync;\nexports.createWriteStream = createWriteStream;\n"]},"metadata":{},"sourceType":"script"}