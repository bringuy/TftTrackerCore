{"ast":null,"code":"const Promise = require('pinkie-promise');\n\nconst exec = require('child_process').exec;\n\nconst temp = require('temp');\n\nconst fs = require('fs');\n\nconst utils = require('../utils');\n\nconst path = require('path');\n\nconst {\n  unlinkP,\n  readAndUnlinkP\n} = utils;\n\nfunction darwinSnapshot(options = {}) {\n  const performScreenCapture = displays => new Promise((resolve, reject) => {\n    // validate displayId\n    const totalDisplays = displays.length;\n\n    if (totalDisplays === 0) {\n      return reject(new Error('No displays detected try dropping screen option'));\n    }\n\n    const maxDisplayId = totalDisplays - 1;\n    const displayId = options.screen || 0;\n\n    if (!Number.isInteger(displayId) || displayId < 0 || displayId > maxDisplayId) {\n      const validChoiceMsg = maxDisplayId === 0 ? '(valid choice is 0 or drop screen option altogether)' : `(valid choice is an integer between 0 and ${maxDisplayId})`;\n      return reject(new Error(`Invalid choice of displayId: ${displayId} ${validChoiceMsg}`));\n    }\n\n    const format = options.format || 'jpg';\n    let filename;\n    let suffix;\n\n    if (options.filename) {\n      const ix = options.filename.lastIndexOf('.');\n      suffix = ix >= 0 ? options.filename.slice(ix) : `.${format}`;\n      filename = '\"' + options.filename.replace(/\"/g, '\\\\\"') + '\"';\n    } else {\n      suffix = `.${format}`;\n    }\n\n    const tmpPaths = Array(displayId + 1).fill(null).map(() => temp.path({\n      suffix\n    }));\n    let pathsToUse = [];\n\n    if (options.filename) {\n      tmpPaths[displayId] = filename;\n    }\n\n    pathsToUse = tmpPaths.slice(0, displayId + 1);\n    exec('screencapture' + ' -x -t ' + format + ' ' + pathsToUse.join(' '), function (err, stdOut) {\n      if (err) {\n        return reject(err);\n      } else if (options.filename) {\n        resolve(path.resolve(options.filename));\n      } else {\n        fs.readFile(tmpPaths[displayId], function (err, img) {\n          if (err) {\n            return reject(err);\n          }\n\n          Promise.all(pathsToUse.map(unlinkP)).then(() => resolve(img)).catch(err => reject(err));\n        });\n      }\n    });\n  });\n\n  return listDisplays().then(displays => {\n    return performScreenCapture(displays);\n  });\n}\n\nconst EXAMPLE_DISPLAYS_OUTPUT = `\nGraphics/Displays:\n\n    Intel Iris:\n\n      Chipset Model: Intel Iris\n      Type: GPU\n      Bus: Built-In\n      VRAM (Dynamic, Max): 1536 MB\n      Vendor: Intel (0x8086)\n      Device ID: 0x0a2e\n      Revision ID: 0x0009\n      Displays:\n        Color LCD:\n          Display Type: Retina LCD\n          Resolution: 2560 x 1600 Retina\n          Retina: Yes\n          Pixel Depth: 32-Bit Color (ARGB8888)\n          Main Display: Yes\n          Mirror: Off\n          Online: Yes\n          Built-In: Yes\n        HP 22cwa:\n          Resolution: 1920 x 1080 @ 60Hz (1080p)\n          Pixel Depth: 32-Bit Color (ARGB8888)\n          Display Serial Number: 6CM7201231\n          Mirror: Off\n          Online: Yes\n          Rotation: Supported\n          Television: Yes\n`;\n\nfunction extractEntries(output) {\n  const entries = [];\n  const entryPattern = /(\\s*)(.*?):(.*)\\n/g;\n  let match;\n\n  while ((match = entryPattern.exec(output)) !== null) {\n    entries.push({\n      indent: match[1].length,\n      key: match[2].trim(),\n      value: match[3].trim()\n    });\n  }\n\n  return entries;\n}\n\nfunction makeSubtree(currIndent, subtree, entries) {\n  let entry;\n\n  while (entry = entries.shift()) {\n    if (entry.value === '') {\n      if (currIndent < entry.indent) {\n        while (entry.key in subtree) {\n          entry.key += '_1';\n        }\n\n        subtree[entry.key] = {};\n        makeSubtree(entry.indent, subtree[entry.key], entries);\n      } else {\n        entries.unshift(entry);\n        return;\n      }\n    } else {\n      while (entry.key in subtree) {\n        entry.key += '_1';\n      }\n\n      subtree[entry.key] = entry.value;\n    }\n  }\n}\n\nfunction movePrimaryToHead(displays) {\n  const primary = displays.filter(e => e.primary);\n  const notPrimary = displays.filter(e => !e.primary);\n  return [...primary, ...notPrimary];\n}\n\nfunction addId(displays) {\n  let id = 0;\n  return displays.map(display => {\n    return Object.assign({}, display, {\n      id: id++\n    });\n  });\n}\n\nfunction parseDisplaysOutput(output) {\n  const tree = {};\n  makeSubtree(-1, tree, extractEntries(output));\n\n  if (!tree['Graphics/Displays']) {\n    return [];\n  }\n\n  const firstGpuKeys = Object.keys(tree['Graphics/Displays']);\n\n  if (!firstGpuKeys || firstGpuKeys.length <= 0) {\n    return [];\n  }\n\n  let displayinfos = [];\n  firstGpuKeys.forEach(gpukey => {\n    const gpu = tree['Graphics/Displays'][gpukey];\n\n    if (gpu.Displays) {\n      const temp = Object.entries(gpu.Displays).map(([name, props]) => {\n        const primary = props['Main Display'] === 'Yes';\n        return {\n          name,\n          primary\n        };\n      });\n      displayinfos = displayinfos.concat(temp);\n    }\n  });\n  return addId(movePrimaryToHead(displayinfos));\n}\n\nfunction listDisplays() {\n  return new Promise((resolve, reject) => {\n    exec('system_profiler SPDisplaysDataType', (err, stdout) => {\n      if (err) {\n        return reject(err);\n      }\n\n      resolve(parseDisplaysOutput(stdout));\n    });\n  });\n}\n\nfunction all() {\n  return new Promise((resolve, reject) => {\n    listDisplays().then(displays => {\n      const tmpPaths = displays.map(() => temp.path({\n        suffix: '.jpg'\n      }));\n      exec('screencapture -x -t jpg ' + tmpPaths.join(' '), {\n        cwd: __dirname\n      }, function (err, stdOut) {\n        if (err) {\n          return reject(err);\n        } else {\n          Promise.all(tmpPaths.map(readAndUnlinkP)).then(resolve).catch(reject);\n        }\n      });\n    });\n  });\n}\n\ndarwinSnapshot.listDisplays = listDisplays;\ndarwinSnapshot.all = all;\ndarwinSnapshot.parseDisplaysOutput = parseDisplaysOutput;\ndarwinSnapshot.EXAMPLE_DISPLAYS_OUTPUT = EXAMPLE_DISPLAYS_OUTPUT;\nmodule.exports = darwinSnapshot;","map":{"version":3,"sources":["C:/Users/Brian/Desktop/TFTracker/TftTrackerCore/tfttracker-frontend/node_modules/screenshot-desktop/lib/darwin/index.js"],"names":["Promise","require","exec","temp","fs","utils","path","unlinkP","readAndUnlinkP","darwinSnapshot","options","performScreenCapture","displays","resolve","reject","totalDisplays","length","Error","maxDisplayId","displayId","screen","Number","isInteger","validChoiceMsg","format","filename","suffix","ix","lastIndexOf","slice","replace","tmpPaths","Array","fill","map","pathsToUse","join","err","stdOut","readFile","img","all","then","catch","listDisplays","EXAMPLE_DISPLAYS_OUTPUT","extractEntries","output","entries","entryPattern","match","push","indent","key","trim","value","makeSubtree","currIndent","subtree","entry","shift","unshift","movePrimaryToHead","primary","filter","e","notPrimary","addId","id","display","Object","assign","parseDisplaysOutput","tree","firstGpuKeys","keys","displayinfos","forEach","gpukey","gpu","Displays","name","props","concat","stdout","cwd","__dirname","module","exports"],"mappings":"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","sourcesContent":["const Promise = require('pinkie-promise')\nconst exec = require('child_process').exec\nconst temp = require('temp')\nconst fs = require('fs')\nconst utils = require('../utils')\nconst path = require('path')\n\nconst { unlinkP, readAndUnlinkP } = utils\n\nfunction darwinSnapshot (options = {}) {\n  const performScreenCapture = displays => new Promise((resolve, reject) => {\n    // validate displayId\n    const totalDisplays = displays.length\n    if (totalDisplays === 0) {\n      return reject(new Error('No displays detected try dropping screen option'))\n    }\n    const maxDisplayId = totalDisplays - 1\n    const displayId = options.screen || 0\n    if (!Number.isInteger(displayId) || displayId < 0 || displayId > maxDisplayId) {\n      const validChoiceMsg = (maxDisplayId === 0) ? '(valid choice is 0 or drop screen option altogether)' : `(valid choice is an integer between 0 and ${maxDisplayId})`\n      return reject(new Error(`Invalid choice of displayId: ${displayId} ${validChoiceMsg}`))\n    }\n\n    const format = options.format || 'jpg'\n    let filename\n    let suffix\n    if (options.filename) {\n      const ix = options.filename.lastIndexOf('.')\n      suffix = ix >= 0 ? options.filename.slice(ix) : `.${format}`\n      filename = '\"' + options.filename.replace(/\"/g, '\\\\\"') + '\"'\n    } else {\n      suffix = `.${format}`\n    }\n\n    const tmpPaths = Array(displayId + 1)\n      .fill(null)\n      .map(() => temp.path({ suffix }))\n\n    let pathsToUse = []\n    if (options.filename) {\n      tmpPaths[displayId] = filename\n    }\n    pathsToUse = tmpPaths.slice(0, displayId + 1)\n\n    exec('screencapture' + ' -x -t ' + format + ' ' + pathsToUse.join(' '),\n      function (err, stdOut) {\n        if (err) {\n          return reject(err)\n        } else if (options.filename) {\n          resolve(path.resolve(options.filename))\n        } else {\n          fs.readFile(tmpPaths[displayId], function (err, img) {\n            if (err) {\n              return reject(err)\n            }\n            Promise.all(pathsToUse.map(unlinkP))\n              .then(() => resolve(img))\n              .catch((err) => reject(err))\n          })\n        }\n      })\n  })\n\n  return listDisplays().then((displays) => { return performScreenCapture(displays) })\n}\n\nconst EXAMPLE_DISPLAYS_OUTPUT = `\nGraphics/Displays:\n\n    Intel Iris:\n\n      Chipset Model: Intel Iris\n      Type: GPU\n      Bus: Built-In\n      VRAM (Dynamic, Max): 1536 MB\n      Vendor: Intel (0x8086)\n      Device ID: 0x0a2e\n      Revision ID: 0x0009\n      Displays:\n        Color LCD:\n          Display Type: Retina LCD\n          Resolution: 2560 x 1600 Retina\n          Retina: Yes\n          Pixel Depth: 32-Bit Color (ARGB8888)\n          Main Display: Yes\n          Mirror: Off\n          Online: Yes\n          Built-In: Yes\n        HP 22cwa:\n          Resolution: 1920 x 1080 @ 60Hz (1080p)\n          Pixel Depth: 32-Bit Color (ARGB8888)\n          Display Serial Number: 6CM7201231\n          Mirror: Off\n          Online: Yes\n          Rotation: Supported\n          Television: Yes\n`\n\nfunction extractEntries (output) {\n  const entries = []\n\n  const entryPattern = /(\\s*)(.*?):(.*)\\n/g\n  let match\n  while ((match = entryPattern.exec(output)) !== null) {\n    entries.push({\n      indent: match[1].length,\n      key: match[2].trim(),\n      value: match[3].trim()\n    })\n  }\n\n  return entries\n}\n\nfunction makeSubtree (currIndent, subtree, entries) {\n  let entry\n  while ((entry = entries.shift())) {\n    if (entry.value === '') {\n      if (currIndent < entry.indent) {\n        while (entry.key in subtree) {\n          entry.key += '_1'\n        }\n        subtree[entry.key] = {}\n        makeSubtree(entry.indent, subtree[entry.key], entries)\n      } else {\n        entries.unshift(entry)\n        return\n      }\n    } else {\n      while (entry.key in subtree) {\n        entry.key += '_1'\n      }\n      subtree[entry.key] = entry.value\n    }\n  }\n}\n\nfunction movePrimaryToHead (displays) {\n  const primary = displays.filter(e => e.primary)\n  const notPrimary = displays.filter(e => !e.primary)\n  return [...primary, ...notPrimary]\n}\n\nfunction addId (displays) {\n  let id = 0\n  return displays\n    .map(display => {\n      return Object.assign({}, display, { id: id++ })\n    })\n}\n\nfunction parseDisplaysOutput (output) {\n  const tree = {}\n  makeSubtree(-1, tree, extractEntries(output))\n\n  if (!tree['Graphics/Displays']) {\n    return []\n  }\n\n  const firstGpuKeys = Object.keys(tree['Graphics/Displays'])\n  if (!firstGpuKeys || firstGpuKeys.length <= 0) {\n    return []\n  }\n\n  let displayinfos = []\n\n  firstGpuKeys.forEach(gpukey => {\n    const gpu = tree['Graphics/Displays'][gpukey]\n    if (gpu.Displays) {\n      const temp = Object.entries(gpu.Displays)\n        .map(([name, props]) => {\n          const primary = props['Main Display'] === 'Yes'\n          return { name, primary }\n        })\n      displayinfos = displayinfos.concat(temp)\n    }\n  })\n\n  return addId(movePrimaryToHead(displayinfos))\n}\n\nfunction listDisplays () {\n  return new Promise((resolve, reject) => {\n    exec(\n      'system_profiler SPDisplaysDataType',\n      (err, stdout) => {\n        if (err) {\n          return reject(err)\n        }\n        resolve(parseDisplaysOutput(stdout))\n      })\n  })\n}\n\nfunction all () {\n  return new Promise((resolve, reject) => {\n    listDisplays()\n      .then((displays) => {\n        const tmpPaths = displays.map(() => temp.path({ suffix: '.jpg' }))\n        exec('screencapture -x -t jpg ' + tmpPaths.join(' '), {\n          cwd: __dirname\n        }, function (err, stdOut) {\n          if (err) {\n            return reject(err)\n          } else {\n            Promise.all(tmpPaths.map(readAndUnlinkP))\n              .then(resolve)\n              .catch(reject)\n          }\n        })\n      })\n  })\n}\n\ndarwinSnapshot.listDisplays = listDisplays\ndarwinSnapshot.all = all\ndarwinSnapshot.parseDisplaysOutput = parseDisplaysOutput\ndarwinSnapshot.EXAMPLE_DISPLAYS_OUTPUT = EXAMPLE_DISPLAYS_OUTPUT\n\nmodule.exports = darwinSnapshot\n"]},"metadata":{},"sourceType":"script"}